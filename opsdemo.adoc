ifndef::codedir[:codedir: code]
ifndef::imagesdir[:imagesdir: images]


= OpsDemo

== Setup
This demo assumes you have setup the following: 

* Minikube
* kubens
* Dockers



=== Create NameSpace
----
$ kubectl create namespace opsdemo
$ kubectl get namespaces
NAME          STATUS    AGE
default       Active    22h
opsdemo       Active    6m
kube-public   Active    21h
kube-system   Active    22h
----

=== Build the initial docker image
----
$ eval $(minikube docker-env)
$ docker images | grep 9steps
$ docker build -t 9stepsawesome/myboot:v1 .
----

=== Test that docker image
----
$ minikube ip
$ docker run -it -p 8080:8080 9stepsawesome/myboot:v1 
$ curl $(minikube ip):8080
----

== Lightweight deployment Demo

Now that we have a docker image, we can quickly spin up a 2 node app server using Kubernetes 

Review the content of the Kubefile 
----
$ cat kubefiles/myboot-deployment.yml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: myboot
  name: myboot
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myboot
  template:
    metadata:
      labels:
        app: myboot
    spec:
      containers:
      - name: myboot
        image: 9stepsawesome/myboot:v1
        ports:
          - containerPort: 8080

----


note it's using the docker image we built earlier 9stepsawesome/myboot:v1 

----
# tell kubernetes to create a deployment of app servers 
$ kubectl create -f kubefiles/myboot-deployment.yml
----

check what happened on another window 
====
----
# watch kubectl get all 
NAME                         READY   STATUS    RESTARTS   AGE
pod/myboot-5d966db4f-vhfwq   1/1     Running   0          4s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   16s

NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/myboot   1         1         1            1           4s

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/myboot-5d966db4f   1         1         1       4s
====
----
----

Create a Service
----
$ kubectl create -f kubefiles/myboot-service.yml 
----

observe what happened in the other window
====
----
NAME                         READY   STATUS    RESTARTS   AGE
pod/myboot-5d966db4f-vhfwq   1/1     Running   0          3m

NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
service/kubernetes   ClusterIP      10.96.0.1      <none>        443/TCP          3m
service/myboot       LoadBalancer   10.101.41.51   <pending>     8080:31416/TCP   20s

NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/myboot   1         1         1            1           3m

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/myboot-5d966db4f   1         1         1       3m
----
====

Get the nodePort
----
$ kubectl get service/myboot -o jsonpath="{.spec.ports[*].nodePort}"
----

Curl that url + nodePort
----
$ curl $(minikube ip):$(kubectl get service/myboot -o jsonpath="{.spec.ports[*].nodePort}")
----

Perhaps build a little loop to curl that endpoint
[source, bash]
----
while true
do 
  curl $(minikube ip):$(kubectl get service/myboot -o jsonpath="{.spec.ports[*].nodePort}")
  sleep .5;
done
----

Let's scale up the application to 3 replicas, there are several possible ways to achieve this result.

You can edit the myboot-deployment.yml, updating replicas 
----

# edit the myboot-deployment.yml and set replica to 2 
$ kubectl replace -f kubefiles/myboot-deployment.yml
----

Or use the kubectl scale command
----
$ kubectl scale --replicas=3 deployment/myboot
----

Kubernetes also provides you a way to 'patch' or to live edit the deployment yaml file by using kubectl edit command 


=== Self-healing infrastructure 
When your application has issues and instances would die sporadically, manual restart is a pain. Kubernetes watches the instances and restarts them if any of them dies unexpectedly 

----
# get the NAME of first pod 
$ kubectl get pods -o json | jq -r '.items[0].metadata.name' 

# kill the first pod and observe 
$ kubectl delete pod $(kubectl get pods -o json | jq -r '.items[0].metadata.name')

----



=== Fast Deployment (near zero down time)


First, update MyRESTController.java so that it prints something else 
----
greeting = environment.getProperty("GREETING","DevHero");
----

Compile & Build the fat jar
----
# cd into springboot directory 
$ mvn clean package
----

ou can test with "java -jar target/boot-demo-0.0.1.jar" and "curl localhost:8080".  Ideally, you would have unit tests executed with "mvn test" as well.

Build the new docker image with a v2 tag
----
$ docker build -t 9stepsawesome/myboot:v2 .
$ docker images | grep myboot
----

Rollout the update
----
# in a separate window, watch kubectl get all 

$ kubectl set image deployment/myboot myboot=9stepsawesome/myboot:v2
----


from the curl pulling you'll see that nodes will drop off and new nodes will come online 

----
curl: (7) Failed to connect to 192.168.64.10 port 31416: Connection refused
DevHero from Spring Boot! 0 on myboot-5955897c9b-klsvz
curl: (7) Failed to connect to 192.168.64.10 port 31416: Connection refused
DevHero from Spring Boot! 1 on myboot-5955897c9b-klsvz
DevHero from Spring Boot! 2 on myboot-5955897c9b-klsvz
DevHero from Spring Boot! 0 on myboot-5955897c9b-lxz77
DevHero from Spring Boot! 1 on myboot-5955897c9b-lxz77
DevHero from Spring Boot! 2 on myboot-5955897c9b-lxz77
----



=== Effortless Roll-back 

Let's undo the rollout 
----
$ kubectl rollout undo deployment/myboot 
----

observe in the curl window 
----
curl: (7) Failed to connect to 192.168.64.10 port 31416: Connection refused
curl: (7) Failed to connect to 192.168.64.10 port 31416: Connection refused
curl: (7) Failed to connect to 192.168.64.10 port 31416: Connection refused
Helloooo from Spring Boot! 0 on myboot-5d966db4f-d784z
Helloooo from Spring Boot! 1 on myboot-5d966db4f-d784z
Helloooo from Spring Boot! 0 on myboot-5d966db4f-z2b4d
Helloooo from Spring Boot! 2 on myboot-5d966db4f-d784z
----



=== Zero Downtime Deployment



=== Effortless Roll-back 



